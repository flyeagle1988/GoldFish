// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class SINGLE_NODE_INFO;
class COLUMN_INFO;
class TB_INFO;
class DATABASE_INFO;
class TASK_INFO;
class GROUP_DB_INFO;
class ROWKEY_ENTRY;

enum COLUMN_INFO_ColumnType {
  COLUMN_INFO_ColumnType_VARCHAR = 0,
  COLUMN_INFO_ColumnType_INTTYPE = 1,
  COLUMN_INFO_ColumnType_DOUBLETYPE = 2,
  COLUMN_INFO_ColumnType_TEXT = 3,
  COLUMN_INFO_ColumnType_BLOB = 4,
  COLUMN_INFO_ColumnType_TIMESTAMP = 5
};
bool COLUMN_INFO_ColumnType_IsValid(int value);
const COLUMN_INFO_ColumnType COLUMN_INFO_ColumnType_ColumnType_MIN = COLUMN_INFO_ColumnType_VARCHAR;
const COLUMN_INFO_ColumnType COLUMN_INFO_ColumnType_ColumnType_MAX = COLUMN_INFO_ColumnType_TIMESTAMP;
const int COLUMN_INFO_ColumnType_ColumnType_ARRAYSIZE = COLUMN_INFO_ColumnType_ColumnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* COLUMN_INFO_ColumnType_descriptor();
inline const ::std::string& COLUMN_INFO_ColumnType_Name(COLUMN_INFO_ColumnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    COLUMN_INFO_ColumnType_descriptor(), value);
}
inline bool COLUMN_INFO_ColumnType_Parse(
    const ::std::string& name, COLUMN_INFO_ColumnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<COLUMN_INFO_ColumnType>(
    COLUMN_INFO_ColumnType_descriptor(), name, value);
}
// ===================================================================

class SINGLE_NODE_INFO : public ::google::protobuf::Message {
 public:
  SINGLE_NODE_INFO();
  virtual ~SINGLE_NODE_INFO();

  SINGLE_NODE_INFO(const SINGLE_NODE_INFO& from);

  inline SINGLE_NODE_INFO& operator=(const SINGLE_NODE_INFO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SINGLE_NODE_INFO& default_instance();

  void Swap(SINGLE_NODE_INFO* other);

  // implements Message ----------------------------------------------

  SINGLE_NODE_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SINGLE_NODE_INFO& from);
  void MergeFrom(const SINGLE_NODE_INFO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 nodeId = 1;
  inline bool has_nodeid() const;
  inline void clear_nodeid();
  static const int kNodeIdFieldNumber = 1;
  inline ::google::protobuf::uint32 nodeid() const;
  inline void set_nodeid(::google::protobuf::uint32 value);

  // optional string nodeStatus = 2;
  inline bool has_nodestatus() const;
  inline void clear_nodestatus();
  static const int kNodeStatusFieldNumber = 2;
  inline const ::std::string& nodestatus() const;
  inline void set_nodestatus(const ::std::string& value);
  inline void set_nodestatus(const char* value);
  inline void set_nodestatus(const char* value, size_t size);
  inline ::std::string* mutable_nodestatus();
  inline ::std::string* release_nodestatus();
  inline void set_allocated_nodestatus(::std::string* nodestatus);

  // optional string nodeIp = 3;
  inline bool has_nodeip() const;
  inline void clear_nodeip();
  static const int kNodeIpFieldNumber = 3;
  inline const ::std::string& nodeip() const;
  inline void set_nodeip(const ::std::string& value);
  inline void set_nodeip(const char* value);
  inline void set_nodeip(const char* value, size_t size);
  inline ::std::string* mutable_nodeip();
  inline ::std::string* release_nodeip();
  inline void set_allocated_nodeip(::std::string* nodeip);

  // optional uint32 nodePort = 4;
  inline bool has_nodeport() const;
  inline void clear_nodeport();
  static const int kNodePortFieldNumber = 4;
  inline ::google::protobuf::uint32 nodeport() const;
  inline void set_nodeport(::google::protobuf::uint32 value);

  // optional uint32 core = 5;
  inline bool has_core() const;
  inline void clear_core();
  static const int kCoreFieldNumber = 5;
  inline ::google::protobuf::uint32 core() const;
  inline void set_core(::google::protobuf::uint32 value);

  // optional uint32 memSize = 6;
  inline bool has_memsize() const;
  inline void clear_memsize();
  static const int kMemSizeFieldNumber = 6;
  inline ::google::protobuf::uint32 memsize() const;
  inline void set_memsize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SINGLE_NODE_INFO)
 private:
  inline void set_has_nodeid();
  inline void clear_has_nodeid();
  inline void set_has_nodestatus();
  inline void clear_has_nodestatus();
  inline void set_has_nodeip();
  inline void clear_has_nodeip();
  inline void set_has_nodeport();
  inline void clear_has_nodeport();
  inline void set_has_core();
  inline void clear_has_core();
  inline void set_has_memsize();
  inline void clear_has_memsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nodestatus_;
  ::google::protobuf::uint32 nodeid_;
  ::google::protobuf::uint32 nodeport_;
  ::std::string* nodeip_;
  ::google::protobuf::uint32 core_;
  ::google::protobuf::uint32 memsize_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static SINGLE_NODE_INFO* default_instance_;
};
// -------------------------------------------------------------------

class COLUMN_INFO : public ::google::protobuf::Message {
 public:
  COLUMN_INFO();
  virtual ~COLUMN_INFO();

  COLUMN_INFO(const COLUMN_INFO& from);

  inline COLUMN_INFO& operator=(const COLUMN_INFO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const COLUMN_INFO& default_instance();

  void Swap(COLUMN_INFO* other);

  // implements Message ----------------------------------------------

  COLUMN_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const COLUMN_INFO& from);
  void MergeFrom(const COLUMN_INFO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef COLUMN_INFO_ColumnType ColumnType;
  static const ColumnType VARCHAR = COLUMN_INFO_ColumnType_VARCHAR;
  static const ColumnType INTTYPE = COLUMN_INFO_ColumnType_INTTYPE;
  static const ColumnType DOUBLETYPE = COLUMN_INFO_ColumnType_DOUBLETYPE;
  static const ColumnType TEXT = COLUMN_INFO_ColumnType_TEXT;
  static const ColumnType BLOB = COLUMN_INFO_ColumnType_BLOB;
  static const ColumnType TIMESTAMP = COLUMN_INFO_ColumnType_TIMESTAMP;
  static inline bool ColumnType_IsValid(int value) {
    return COLUMN_INFO_ColumnType_IsValid(value);
  }
  static const ColumnType ColumnType_MIN =
    COLUMN_INFO_ColumnType_ColumnType_MIN;
  static const ColumnType ColumnType_MAX =
    COLUMN_INFO_ColumnType_ColumnType_MAX;
  static const int ColumnType_ARRAYSIZE =
    COLUMN_INFO_ColumnType_ColumnType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ColumnType_descriptor() {
    return COLUMN_INFO_ColumnType_descriptor();
  }
  static inline const ::std::string& ColumnType_Name(ColumnType value) {
    return COLUMN_INFO_ColumnType_Name(value);
  }
  static inline bool ColumnType_Parse(const ::std::string& name,
      ColumnType* value) {
    return COLUMN_INFO_ColumnType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string columnName = 1;
  inline bool has_columnname() const;
  inline void clear_columnname();
  static const int kColumnNameFieldNumber = 1;
  inline const ::std::string& columnname() const;
  inline void set_columnname(const ::std::string& value);
  inline void set_columnname(const char* value);
  inline void set_columnname(const char* value, size_t size);
  inline ::std::string* mutable_columnname();
  inline ::std::string* release_columnname();
  inline void set_allocated_columnname(::std::string* columnname);

  // required .COLUMN_INFO.ColumnType columnType = 2;
  inline bool has_columntype() const;
  inline void clear_columntype();
  static const int kColumnTypeFieldNumber = 2;
  inline ::COLUMN_INFO_ColumnType columntype() const;
  inline void set_columntype(::COLUMN_INFO_ColumnType value);

  // @@protoc_insertion_point(class_scope:COLUMN_INFO)
 private:
  inline void set_has_columnname();
  inline void clear_has_columnname();
  inline void set_has_columntype();
  inline void clear_has_columntype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* columnname_;
  int columntype_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static COLUMN_INFO* default_instance_;
};
// -------------------------------------------------------------------

class TB_INFO : public ::google::protobuf::Message {
 public:
  TB_INFO();
  virtual ~TB_INFO();

  TB_INFO(const TB_INFO& from);

  inline TB_INFO& operator=(const TB_INFO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TB_INFO& default_instance();

  void Swap(TB_INFO* other);

  // implements Message ----------------------------------------------

  TB_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TB_INFO& from);
  void MergeFrom(const TB_INFO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string tbName = 1;
  inline bool has_tbname() const;
  inline void clear_tbname();
  static const int kTbNameFieldNumber = 1;
  inline const ::std::string& tbname() const;
  inline void set_tbname(const ::std::string& value);
  inline void set_tbname(const char* value);
  inline void set_tbname(const char* value, size_t size);
  inline ::std::string* mutable_tbname();
  inline ::std::string* release_tbname();
  inline void set_allocated_tbname(::std::string* tbname);

  // repeated .COLUMN_INFO columnInfo = 2;
  inline int columninfo_size() const;
  inline void clear_columninfo();
  static const int kColumnInfoFieldNumber = 2;
  inline const ::COLUMN_INFO& columninfo(int index) const;
  inline ::COLUMN_INFO* mutable_columninfo(int index);
  inline ::COLUMN_INFO* add_columninfo();
  inline const ::google::protobuf::RepeatedPtrField< ::COLUMN_INFO >&
      columninfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::COLUMN_INFO >*
      mutable_columninfo();

  // required uint32 rowNum = 3;
  inline bool has_rownum() const;
  inline void clear_rownum();
  static const int kRowNumFieldNumber = 3;
  inline ::google::protobuf::uint32 rownum() const;
  inline void set_rownum(::google::protobuf::uint32 value);

  // required uint32 tbSize = 4;
  inline bool has_tbsize() const;
  inline void clear_tbsize();
  static const int kTbSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 tbsize() const;
  inline void set_tbsize(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TB_INFO)
 private:
  inline void set_has_tbname();
  inline void clear_has_tbname();
  inline void set_has_rownum();
  inline void clear_has_rownum();
  inline void set_has_tbsize();
  inline void clear_has_tbsize();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tbname_;
  ::google::protobuf::RepeatedPtrField< ::COLUMN_INFO > columninfo_;
  ::google::protobuf::uint32 rownum_;
  ::google::protobuf::uint32 tbsize_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TB_INFO* default_instance_;
};
// -------------------------------------------------------------------

class DATABASE_INFO : public ::google::protobuf::Message {
 public:
  DATABASE_INFO();
  virtual ~DATABASE_INFO();

  DATABASE_INFO(const DATABASE_INFO& from);

  inline DATABASE_INFO& operator=(const DATABASE_INFO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DATABASE_INFO& default_instance();

  void Swap(DATABASE_INFO* other);

  // implements Message ----------------------------------------------

  DATABASE_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DATABASE_INFO& from);
  void MergeFrom(const DATABASE_INFO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dbName = 1;
  inline bool has_dbname() const;
  inline void clear_dbname();
  static const int kDbNameFieldNumber = 1;
  inline const ::std::string& dbname() const;
  inline void set_dbname(const ::std::string& value);
  inline void set_dbname(const char* value);
  inline void set_dbname(const char* value, size_t size);
  inline ::std::string* mutable_dbname();
  inline ::std::string* release_dbname();
  inline void set_allocated_dbname(::std::string* dbname);

  // required int32 dbid = 2;
  inline bool has_dbid() const;
  inline void clear_dbid();
  static const int kDbidFieldNumber = 2;
  inline ::google::protobuf::int32 dbid() const;
  inline void set_dbid(::google::protobuf::int32 value);

  // repeated .TB_INFO tbInfo = 3;
  inline int tbinfo_size() const;
  inline void clear_tbinfo();
  static const int kTbInfoFieldNumber = 3;
  inline const ::TB_INFO& tbinfo(int index) const;
  inline ::TB_INFO* mutable_tbinfo(int index);
  inline ::TB_INFO* add_tbinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::TB_INFO >&
      tbinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::TB_INFO >*
      mutable_tbinfo();

  // @@protoc_insertion_point(class_scope:DATABASE_INFO)
 private:
  inline void set_has_dbname();
  inline void clear_has_dbname();
  inline void set_has_dbid();
  inline void clear_has_dbid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* dbname_;
  ::google::protobuf::RepeatedPtrField< ::TB_INFO > tbinfo_;
  ::google::protobuf::int32 dbid_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DATABASE_INFO* default_instance_;
};
// -------------------------------------------------------------------

class TASK_INFO : public ::google::protobuf::Message {
 public:
  TASK_INFO();
  virtual ~TASK_INFO();

  TASK_INFO(const TASK_INFO& from);

  inline TASK_INFO& operator=(const TASK_INFO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TASK_INFO& default_instance();

  void Swap(TASK_INFO* other);

  // implements Message ----------------------------------------------

  TASK_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TASK_INFO& from);
  void MergeFrom(const TASK_INFO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 taskType = 1;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTaskTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 tasktype() const;
  inline void set_tasktype(::google::protobuf::uint32 value);

  // required uint32 schedule = 2;
  inline bool has_schedule() const;
  inline void clear_schedule();
  static const int kScheduleFieldNumber = 2;
  inline ::google::protobuf::uint32 schedule() const;
  inline void set_schedule(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:TASK_INFO)
 private:
  inline void set_has_tasktype();
  inline void clear_has_tasktype();
  inline void set_has_schedule();
  inline void clear_has_schedule();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 tasktype_;
  ::google::protobuf::uint32 schedule_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TASK_INFO* default_instance_;
};
// -------------------------------------------------------------------

class GROUP_DB_INFO : public ::google::protobuf::Message {
 public:
  GROUP_DB_INFO();
  virtual ~GROUP_DB_INFO();

  GROUP_DB_INFO(const GROUP_DB_INFO& from);

  inline GROUP_DB_INFO& operator=(const GROUP_DB_INFO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GROUP_DB_INFO& default_instance();

  void Swap(GROUP_DB_INFO* other);

  // implements Message ----------------------------------------------

  GROUP_DB_INFO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GROUP_DB_INFO& from);
  void MergeFrom(const GROUP_DB_INFO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string groupName = 1;
  inline bool has_groupname() const;
  inline void clear_groupname();
  static const int kGroupNameFieldNumber = 1;
  inline const ::std::string& groupname() const;
  inline void set_groupname(const ::std::string& value);
  inline void set_groupname(const char* value);
  inline void set_groupname(const char* value, size_t size);
  inline ::std::string* mutable_groupname();
  inline ::std::string* release_groupname();
  inline void set_allocated_groupname(::std::string* groupname);

  // repeated string databasename = 2;
  inline int databasename_size() const;
  inline void clear_databasename();
  static const int kDatabasenameFieldNumber = 2;
  inline const ::std::string& databasename(int index) const;
  inline ::std::string* mutable_databasename(int index);
  inline void set_databasename(int index, const ::std::string& value);
  inline void set_databasename(int index, const char* value);
  inline void set_databasename(int index, const char* value, size_t size);
  inline ::std::string* add_databasename();
  inline void add_databasename(const ::std::string& value);
  inline void add_databasename(const char* value);
  inline void add_databasename(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& databasename() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_databasename();

  // @@protoc_insertion_point(class_scope:GROUP_DB_INFO)
 private:
  inline void set_has_groupname();
  inline void clear_has_groupname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* groupname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> databasename_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static GROUP_DB_INFO* default_instance_;
};
// -------------------------------------------------------------------

class ROWKEY_ENTRY : public ::google::protobuf::Message {
 public:
  ROWKEY_ENTRY();
  virtual ~ROWKEY_ENTRY();

  ROWKEY_ENTRY(const ROWKEY_ENTRY& from);

  inline ROWKEY_ENTRY& operator=(const ROWKEY_ENTRY& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ROWKEY_ENTRY& default_instance();

  void Swap(ROWKEY_ENTRY* other);

  // implements Message ----------------------------------------------

  ROWKEY_ENTRY* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ROWKEY_ENTRY& from);
  void MergeFrom(const ROWKEY_ENTRY& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 rowKey = 1;
  inline bool has_rowkey() const;
  inline void clear_rowkey();
  static const int kRowKeyFieldNumber = 1;
  inline ::google::protobuf::uint32 rowkey() const;
  inline void set_rowkey(::google::protobuf::uint32 value);

  // required uint32 entry = 2;
  inline bool has_entry() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 2;
  inline ::google::protobuf::uint32 entry() const;
  inline void set_entry(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ROWKEY_ENTRY)
 private:
  inline void set_has_rowkey();
  inline void clear_has_rowkey();
  inline void set_has_entry();
  inline void clear_has_entry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 rowkey_;
  ::google::protobuf::uint32 entry_;
  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ROWKEY_ENTRY* default_instance_;
};
// ===================================================================


// ===================================================================

// SINGLE_NODE_INFO

// required uint32 nodeId = 1;
inline bool SINGLE_NODE_INFO::has_nodeid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SINGLE_NODE_INFO::set_has_nodeid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SINGLE_NODE_INFO::clear_has_nodeid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SINGLE_NODE_INFO::clear_nodeid() {
  nodeid_ = 0u;
  clear_has_nodeid();
}
inline ::google::protobuf::uint32 SINGLE_NODE_INFO::nodeid() const {
  // @@protoc_insertion_point(field_get:SINGLE_NODE_INFO.nodeId)
  return nodeid_;
}
inline void SINGLE_NODE_INFO::set_nodeid(::google::protobuf::uint32 value) {
  set_has_nodeid();
  nodeid_ = value;
  // @@protoc_insertion_point(field_set:SINGLE_NODE_INFO.nodeId)
}

// optional string nodeStatus = 2;
inline bool SINGLE_NODE_INFO::has_nodestatus() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SINGLE_NODE_INFO::set_has_nodestatus() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SINGLE_NODE_INFO::clear_has_nodestatus() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SINGLE_NODE_INFO::clear_nodestatus() {
  if (nodestatus_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodestatus_->clear();
  }
  clear_has_nodestatus();
}
inline const ::std::string& SINGLE_NODE_INFO::nodestatus() const {
  // @@protoc_insertion_point(field_get:SINGLE_NODE_INFO.nodeStatus)
  return *nodestatus_;
}
inline void SINGLE_NODE_INFO::set_nodestatus(const ::std::string& value) {
  set_has_nodestatus();
  if (nodestatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodestatus_ = new ::std::string;
  }
  nodestatus_->assign(value);
  // @@protoc_insertion_point(field_set:SINGLE_NODE_INFO.nodeStatus)
}
inline void SINGLE_NODE_INFO::set_nodestatus(const char* value) {
  set_has_nodestatus();
  if (nodestatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodestatus_ = new ::std::string;
  }
  nodestatus_->assign(value);
  // @@protoc_insertion_point(field_set_char:SINGLE_NODE_INFO.nodeStatus)
}
inline void SINGLE_NODE_INFO::set_nodestatus(const char* value, size_t size) {
  set_has_nodestatus();
  if (nodestatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodestatus_ = new ::std::string;
  }
  nodestatus_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SINGLE_NODE_INFO.nodeStatus)
}
inline ::std::string* SINGLE_NODE_INFO::mutable_nodestatus() {
  set_has_nodestatus();
  if (nodestatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodestatus_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SINGLE_NODE_INFO.nodeStatus)
  return nodestatus_;
}
inline ::std::string* SINGLE_NODE_INFO::release_nodestatus() {
  clear_has_nodestatus();
  if (nodestatus_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nodestatus_;
    nodestatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SINGLE_NODE_INFO::set_allocated_nodestatus(::std::string* nodestatus) {
  if (nodestatus_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nodestatus_;
  }
  if (nodestatus) {
    set_has_nodestatus();
    nodestatus_ = nodestatus;
  } else {
    clear_has_nodestatus();
    nodestatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SINGLE_NODE_INFO.nodeStatus)
}

// optional string nodeIp = 3;
inline bool SINGLE_NODE_INFO::has_nodeip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SINGLE_NODE_INFO::set_has_nodeip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SINGLE_NODE_INFO::clear_has_nodeip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SINGLE_NODE_INFO::clear_nodeip() {
  if (nodeip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodeip_->clear();
  }
  clear_has_nodeip();
}
inline const ::std::string& SINGLE_NODE_INFO::nodeip() const {
  // @@protoc_insertion_point(field_get:SINGLE_NODE_INFO.nodeIp)
  return *nodeip_;
}
inline void SINGLE_NODE_INFO::set_nodeip(const ::std::string& value) {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodeip_ = new ::std::string;
  }
  nodeip_->assign(value);
  // @@protoc_insertion_point(field_set:SINGLE_NODE_INFO.nodeIp)
}
inline void SINGLE_NODE_INFO::set_nodeip(const char* value) {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodeip_ = new ::std::string;
  }
  nodeip_->assign(value);
  // @@protoc_insertion_point(field_set_char:SINGLE_NODE_INFO.nodeIp)
}
inline void SINGLE_NODE_INFO::set_nodeip(const char* value, size_t size) {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodeip_ = new ::std::string;
  }
  nodeip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SINGLE_NODE_INFO.nodeIp)
}
inline ::std::string* SINGLE_NODE_INFO::mutable_nodeip() {
  set_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nodeip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:SINGLE_NODE_INFO.nodeIp)
  return nodeip_;
}
inline ::std::string* SINGLE_NODE_INFO::release_nodeip() {
  clear_has_nodeip();
  if (nodeip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nodeip_;
    nodeip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SINGLE_NODE_INFO::set_allocated_nodeip(::std::string* nodeip) {
  if (nodeip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nodeip_;
  }
  if (nodeip) {
    set_has_nodeip();
    nodeip_ = nodeip;
  } else {
    clear_has_nodeip();
    nodeip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:SINGLE_NODE_INFO.nodeIp)
}

// optional uint32 nodePort = 4;
inline bool SINGLE_NODE_INFO::has_nodeport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SINGLE_NODE_INFO::set_has_nodeport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SINGLE_NODE_INFO::clear_has_nodeport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SINGLE_NODE_INFO::clear_nodeport() {
  nodeport_ = 0u;
  clear_has_nodeport();
}
inline ::google::protobuf::uint32 SINGLE_NODE_INFO::nodeport() const {
  // @@protoc_insertion_point(field_get:SINGLE_NODE_INFO.nodePort)
  return nodeport_;
}
inline void SINGLE_NODE_INFO::set_nodeport(::google::protobuf::uint32 value) {
  set_has_nodeport();
  nodeport_ = value;
  // @@protoc_insertion_point(field_set:SINGLE_NODE_INFO.nodePort)
}

// optional uint32 core = 5;
inline bool SINGLE_NODE_INFO::has_core() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SINGLE_NODE_INFO::set_has_core() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SINGLE_NODE_INFO::clear_has_core() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SINGLE_NODE_INFO::clear_core() {
  core_ = 0u;
  clear_has_core();
}
inline ::google::protobuf::uint32 SINGLE_NODE_INFO::core() const {
  // @@protoc_insertion_point(field_get:SINGLE_NODE_INFO.core)
  return core_;
}
inline void SINGLE_NODE_INFO::set_core(::google::protobuf::uint32 value) {
  set_has_core();
  core_ = value;
  // @@protoc_insertion_point(field_set:SINGLE_NODE_INFO.core)
}

// optional uint32 memSize = 6;
inline bool SINGLE_NODE_INFO::has_memsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SINGLE_NODE_INFO::set_has_memsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SINGLE_NODE_INFO::clear_has_memsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SINGLE_NODE_INFO::clear_memsize() {
  memsize_ = 0u;
  clear_has_memsize();
}
inline ::google::protobuf::uint32 SINGLE_NODE_INFO::memsize() const {
  // @@protoc_insertion_point(field_get:SINGLE_NODE_INFO.memSize)
  return memsize_;
}
inline void SINGLE_NODE_INFO::set_memsize(::google::protobuf::uint32 value) {
  set_has_memsize();
  memsize_ = value;
  // @@protoc_insertion_point(field_set:SINGLE_NODE_INFO.memSize)
}

// -------------------------------------------------------------------

// COLUMN_INFO

// required string columnName = 1;
inline bool COLUMN_INFO::has_columnname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void COLUMN_INFO::set_has_columnname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void COLUMN_INFO::clear_has_columnname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void COLUMN_INFO::clear_columnname() {
  if (columnname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    columnname_->clear();
  }
  clear_has_columnname();
}
inline const ::std::string& COLUMN_INFO::columnname() const {
  // @@protoc_insertion_point(field_get:COLUMN_INFO.columnName)
  return *columnname_;
}
inline void COLUMN_INFO::set_columnname(const ::std::string& value) {
  set_has_columnname();
  if (columnname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    columnname_ = new ::std::string;
  }
  columnname_->assign(value);
  // @@protoc_insertion_point(field_set:COLUMN_INFO.columnName)
}
inline void COLUMN_INFO::set_columnname(const char* value) {
  set_has_columnname();
  if (columnname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    columnname_ = new ::std::string;
  }
  columnname_->assign(value);
  // @@protoc_insertion_point(field_set_char:COLUMN_INFO.columnName)
}
inline void COLUMN_INFO::set_columnname(const char* value, size_t size) {
  set_has_columnname();
  if (columnname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    columnname_ = new ::std::string;
  }
  columnname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:COLUMN_INFO.columnName)
}
inline ::std::string* COLUMN_INFO::mutable_columnname() {
  set_has_columnname();
  if (columnname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    columnname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:COLUMN_INFO.columnName)
  return columnname_;
}
inline ::std::string* COLUMN_INFO::release_columnname() {
  clear_has_columnname();
  if (columnname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = columnname_;
    columnname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void COLUMN_INFO::set_allocated_columnname(::std::string* columnname) {
  if (columnname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete columnname_;
  }
  if (columnname) {
    set_has_columnname();
    columnname_ = columnname;
  } else {
    clear_has_columnname();
    columnname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:COLUMN_INFO.columnName)
}

// required .COLUMN_INFO.ColumnType columnType = 2;
inline bool COLUMN_INFO::has_columntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void COLUMN_INFO::set_has_columntype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void COLUMN_INFO::clear_has_columntype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void COLUMN_INFO::clear_columntype() {
  columntype_ = 0;
  clear_has_columntype();
}
inline ::COLUMN_INFO_ColumnType COLUMN_INFO::columntype() const {
  // @@protoc_insertion_point(field_get:COLUMN_INFO.columnType)
  return static_cast< ::COLUMN_INFO_ColumnType >(columntype_);
}
inline void COLUMN_INFO::set_columntype(::COLUMN_INFO_ColumnType value) {
  assert(::COLUMN_INFO_ColumnType_IsValid(value));
  set_has_columntype();
  columntype_ = value;
  // @@protoc_insertion_point(field_set:COLUMN_INFO.columnType)
}

// -------------------------------------------------------------------

// TB_INFO

// required string tbName = 1;
inline bool TB_INFO::has_tbname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TB_INFO::set_has_tbname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TB_INFO::clear_has_tbname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TB_INFO::clear_tbname() {
  if (tbname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbname_->clear();
  }
  clear_has_tbname();
}
inline const ::std::string& TB_INFO::tbname() const {
  // @@protoc_insertion_point(field_get:TB_INFO.tbName)
  return *tbname_;
}
inline void TB_INFO::set_tbname(const ::std::string& value) {
  set_has_tbname();
  if (tbname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbname_ = new ::std::string;
  }
  tbname_->assign(value);
  // @@protoc_insertion_point(field_set:TB_INFO.tbName)
}
inline void TB_INFO::set_tbname(const char* value) {
  set_has_tbname();
  if (tbname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbname_ = new ::std::string;
  }
  tbname_->assign(value);
  // @@protoc_insertion_point(field_set_char:TB_INFO.tbName)
}
inline void TB_INFO::set_tbname(const char* value, size_t size) {
  set_has_tbname();
  if (tbname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbname_ = new ::std::string;
  }
  tbname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TB_INFO.tbName)
}
inline ::std::string* TB_INFO::mutable_tbname() {
  set_has_tbname();
  if (tbname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tbname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TB_INFO.tbName)
  return tbname_;
}
inline ::std::string* TB_INFO::release_tbname() {
  clear_has_tbname();
  if (tbname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tbname_;
    tbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TB_INFO::set_allocated_tbname(::std::string* tbname) {
  if (tbname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tbname_;
  }
  if (tbname) {
    set_has_tbname();
    tbname_ = tbname;
  } else {
    clear_has_tbname();
    tbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TB_INFO.tbName)
}

// repeated .COLUMN_INFO columnInfo = 2;
inline int TB_INFO::columninfo_size() const {
  return columninfo_.size();
}
inline void TB_INFO::clear_columninfo() {
  columninfo_.Clear();
}
inline const ::COLUMN_INFO& TB_INFO::columninfo(int index) const {
  // @@protoc_insertion_point(field_get:TB_INFO.columnInfo)
  return columninfo_.Get(index);
}
inline ::COLUMN_INFO* TB_INFO::mutable_columninfo(int index) {
  // @@protoc_insertion_point(field_mutable:TB_INFO.columnInfo)
  return columninfo_.Mutable(index);
}
inline ::COLUMN_INFO* TB_INFO::add_columninfo() {
  // @@protoc_insertion_point(field_add:TB_INFO.columnInfo)
  return columninfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::COLUMN_INFO >&
TB_INFO::columninfo() const {
  // @@protoc_insertion_point(field_list:TB_INFO.columnInfo)
  return columninfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::COLUMN_INFO >*
TB_INFO::mutable_columninfo() {
  // @@protoc_insertion_point(field_mutable_list:TB_INFO.columnInfo)
  return &columninfo_;
}

// required uint32 rowNum = 3;
inline bool TB_INFO::has_rownum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TB_INFO::set_has_rownum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TB_INFO::clear_has_rownum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TB_INFO::clear_rownum() {
  rownum_ = 0u;
  clear_has_rownum();
}
inline ::google::protobuf::uint32 TB_INFO::rownum() const {
  // @@protoc_insertion_point(field_get:TB_INFO.rowNum)
  return rownum_;
}
inline void TB_INFO::set_rownum(::google::protobuf::uint32 value) {
  set_has_rownum();
  rownum_ = value;
  // @@protoc_insertion_point(field_set:TB_INFO.rowNum)
}

// required uint32 tbSize = 4;
inline bool TB_INFO::has_tbsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TB_INFO::set_has_tbsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TB_INFO::clear_has_tbsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TB_INFO::clear_tbsize() {
  tbsize_ = 0u;
  clear_has_tbsize();
}
inline ::google::protobuf::uint32 TB_INFO::tbsize() const {
  // @@protoc_insertion_point(field_get:TB_INFO.tbSize)
  return tbsize_;
}
inline void TB_INFO::set_tbsize(::google::protobuf::uint32 value) {
  set_has_tbsize();
  tbsize_ = value;
  // @@protoc_insertion_point(field_set:TB_INFO.tbSize)
}

// -------------------------------------------------------------------

// DATABASE_INFO

// required string dbName = 1;
inline bool DATABASE_INFO::has_dbname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DATABASE_INFO::set_has_dbname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DATABASE_INFO::clear_has_dbname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DATABASE_INFO::clear_dbname() {
  if (dbname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dbname_->clear();
  }
  clear_has_dbname();
}
inline const ::std::string& DATABASE_INFO::dbname() const {
  // @@protoc_insertion_point(field_get:DATABASE_INFO.dbName)
  return *dbname_;
}
inline void DATABASE_INFO::set_dbname(const ::std::string& value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
  // @@protoc_insertion_point(field_set:DATABASE_INFO.dbName)
}
inline void DATABASE_INFO::set_dbname(const char* value) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(value);
  // @@protoc_insertion_point(field_set_char:DATABASE_INFO.dbName)
}
inline void DATABASE_INFO::set_dbname(const char* value, size_t size) {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dbname_ = new ::std::string;
  }
  dbname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:DATABASE_INFO.dbName)
}
inline ::std::string* DATABASE_INFO::mutable_dbname() {
  set_has_dbname();
  if (dbname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dbname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:DATABASE_INFO.dbName)
  return dbname_;
}
inline ::std::string* DATABASE_INFO::release_dbname() {
  clear_has_dbname();
  if (dbname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dbname_;
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DATABASE_INFO::set_allocated_dbname(::std::string* dbname) {
  if (dbname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dbname_;
  }
  if (dbname) {
    set_has_dbname();
    dbname_ = dbname;
  } else {
    clear_has_dbname();
    dbname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:DATABASE_INFO.dbName)
}

// required int32 dbid = 2;
inline bool DATABASE_INFO::has_dbid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DATABASE_INFO::set_has_dbid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DATABASE_INFO::clear_has_dbid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DATABASE_INFO::clear_dbid() {
  dbid_ = 0;
  clear_has_dbid();
}
inline ::google::protobuf::int32 DATABASE_INFO::dbid() const {
  // @@protoc_insertion_point(field_get:DATABASE_INFO.dbid)
  return dbid_;
}
inline void DATABASE_INFO::set_dbid(::google::protobuf::int32 value) {
  set_has_dbid();
  dbid_ = value;
  // @@protoc_insertion_point(field_set:DATABASE_INFO.dbid)
}

// repeated .TB_INFO tbInfo = 3;
inline int DATABASE_INFO::tbinfo_size() const {
  return tbinfo_.size();
}
inline void DATABASE_INFO::clear_tbinfo() {
  tbinfo_.Clear();
}
inline const ::TB_INFO& DATABASE_INFO::tbinfo(int index) const {
  // @@protoc_insertion_point(field_get:DATABASE_INFO.tbInfo)
  return tbinfo_.Get(index);
}
inline ::TB_INFO* DATABASE_INFO::mutable_tbinfo(int index) {
  // @@protoc_insertion_point(field_mutable:DATABASE_INFO.tbInfo)
  return tbinfo_.Mutable(index);
}
inline ::TB_INFO* DATABASE_INFO::add_tbinfo() {
  // @@protoc_insertion_point(field_add:DATABASE_INFO.tbInfo)
  return tbinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TB_INFO >&
DATABASE_INFO::tbinfo() const {
  // @@protoc_insertion_point(field_list:DATABASE_INFO.tbInfo)
  return tbinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::TB_INFO >*
DATABASE_INFO::mutable_tbinfo() {
  // @@protoc_insertion_point(field_mutable_list:DATABASE_INFO.tbInfo)
  return &tbinfo_;
}

// -------------------------------------------------------------------

// TASK_INFO

// required uint32 taskType = 1;
inline bool TASK_INFO::has_tasktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TASK_INFO::set_has_tasktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TASK_INFO::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TASK_INFO::clear_tasktype() {
  tasktype_ = 0u;
  clear_has_tasktype();
}
inline ::google::protobuf::uint32 TASK_INFO::tasktype() const {
  // @@protoc_insertion_point(field_get:TASK_INFO.taskType)
  return tasktype_;
}
inline void TASK_INFO::set_tasktype(::google::protobuf::uint32 value) {
  set_has_tasktype();
  tasktype_ = value;
  // @@protoc_insertion_point(field_set:TASK_INFO.taskType)
}

// required uint32 schedule = 2;
inline bool TASK_INFO::has_schedule() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TASK_INFO::set_has_schedule() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TASK_INFO::clear_has_schedule() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TASK_INFO::clear_schedule() {
  schedule_ = 0u;
  clear_has_schedule();
}
inline ::google::protobuf::uint32 TASK_INFO::schedule() const {
  // @@protoc_insertion_point(field_get:TASK_INFO.schedule)
  return schedule_;
}
inline void TASK_INFO::set_schedule(::google::protobuf::uint32 value) {
  set_has_schedule();
  schedule_ = value;
  // @@protoc_insertion_point(field_set:TASK_INFO.schedule)
}

// -------------------------------------------------------------------

// GROUP_DB_INFO

// required string groupName = 1;
inline bool GROUP_DB_INFO::has_groupname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GROUP_DB_INFO::set_has_groupname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GROUP_DB_INFO::clear_has_groupname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GROUP_DB_INFO::clear_groupname() {
  if (groupname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_->clear();
  }
  clear_has_groupname();
}
inline const ::std::string& GROUP_DB_INFO::groupname() const {
  // @@protoc_insertion_point(field_get:GROUP_DB_INFO.groupName)
  return *groupname_;
}
inline void GROUP_DB_INFO::set_groupname(const ::std::string& value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
  // @@protoc_insertion_point(field_set:GROUP_DB_INFO.groupName)
}
inline void GROUP_DB_INFO::set_groupname(const char* value) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(value);
  // @@protoc_insertion_point(field_set_char:GROUP_DB_INFO.groupName)
}
inline void GROUP_DB_INFO::set_groupname(const char* value, size_t size) {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_ = new ::std::string;
  }
  groupname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GROUP_DB_INFO.groupName)
}
inline ::std::string* GROUP_DB_INFO::mutable_groupname() {
  set_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    groupname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:GROUP_DB_INFO.groupName)
  return groupname_;
}
inline ::std::string* GROUP_DB_INFO::release_groupname() {
  clear_has_groupname();
  if (groupname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = groupname_;
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GROUP_DB_INFO::set_allocated_groupname(::std::string* groupname) {
  if (groupname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete groupname_;
  }
  if (groupname) {
    set_has_groupname();
    groupname_ = groupname;
  } else {
    clear_has_groupname();
    groupname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:GROUP_DB_INFO.groupName)
}

// repeated string databasename = 2;
inline int GROUP_DB_INFO::databasename_size() const {
  return databasename_.size();
}
inline void GROUP_DB_INFO::clear_databasename() {
  databasename_.Clear();
}
inline const ::std::string& GROUP_DB_INFO::databasename(int index) const {
  // @@protoc_insertion_point(field_get:GROUP_DB_INFO.databasename)
  return databasename_.Get(index);
}
inline ::std::string* GROUP_DB_INFO::mutable_databasename(int index) {
  // @@protoc_insertion_point(field_mutable:GROUP_DB_INFO.databasename)
  return databasename_.Mutable(index);
}
inline void GROUP_DB_INFO::set_databasename(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:GROUP_DB_INFO.databasename)
  databasename_.Mutable(index)->assign(value);
}
inline void GROUP_DB_INFO::set_databasename(int index, const char* value) {
  databasename_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GROUP_DB_INFO.databasename)
}
inline void GROUP_DB_INFO::set_databasename(int index, const char* value, size_t size) {
  databasename_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GROUP_DB_INFO.databasename)
}
inline ::std::string* GROUP_DB_INFO::add_databasename() {
  return databasename_.Add();
}
inline void GROUP_DB_INFO::add_databasename(const ::std::string& value) {
  databasename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:GROUP_DB_INFO.databasename)
}
inline void GROUP_DB_INFO::add_databasename(const char* value) {
  databasename_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GROUP_DB_INFO.databasename)
}
inline void GROUP_DB_INFO::add_databasename(const char* value, size_t size) {
  databasename_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GROUP_DB_INFO.databasename)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GROUP_DB_INFO::databasename() const {
  // @@protoc_insertion_point(field_list:GROUP_DB_INFO.databasename)
  return databasename_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GROUP_DB_INFO::mutable_databasename() {
  // @@protoc_insertion_point(field_mutable_list:GROUP_DB_INFO.databasename)
  return &databasename_;
}

// -------------------------------------------------------------------

// ROWKEY_ENTRY

// required uint32 rowKey = 1;
inline bool ROWKEY_ENTRY::has_rowkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ROWKEY_ENTRY::set_has_rowkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ROWKEY_ENTRY::clear_has_rowkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ROWKEY_ENTRY::clear_rowkey() {
  rowkey_ = 0u;
  clear_has_rowkey();
}
inline ::google::protobuf::uint32 ROWKEY_ENTRY::rowkey() const {
  // @@protoc_insertion_point(field_get:ROWKEY_ENTRY.rowKey)
  return rowkey_;
}
inline void ROWKEY_ENTRY::set_rowkey(::google::protobuf::uint32 value) {
  set_has_rowkey();
  rowkey_ = value;
  // @@protoc_insertion_point(field_set:ROWKEY_ENTRY.rowKey)
}

// required uint32 entry = 2;
inline bool ROWKEY_ENTRY::has_entry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ROWKEY_ENTRY::set_has_entry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ROWKEY_ENTRY::clear_has_entry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ROWKEY_ENTRY::clear_entry() {
  entry_ = 0u;
  clear_has_entry();
}
inline ::google::protobuf::uint32 ROWKEY_ENTRY::entry() const {
  // @@protoc_insertion_point(field_get:ROWKEY_ENTRY.entry)
  return entry_;
}
inline void ROWKEY_ENTRY::set_entry(::google::protobuf::uint32 value) {
  set_has_entry();
  entry_ = value;
  // @@protoc_insertion_point(field_set:ROWKEY_ENTRY.entry)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::COLUMN_INFO_ColumnType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::COLUMN_INFO_ColumnType>() {
  return ::COLUMN_INFO_ColumnType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
